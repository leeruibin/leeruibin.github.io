<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-双系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/27/双系统/" class="article-date">
  <time datetime="2017-03-27T00:09:10.738Z" itemprop="datePublished">2017-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="title：-学习"><a href="#title：-学习" class="headerlink" title="title： 学习"></a>title： 学习</h2><p>##linux与windows双系统安装</p>
<p>###安装linux###<br>需要使用linuxu盘制作工具制作启动u盘<br>推荐使用ultraiso<br>曾使用过Universal-USB-Installer使用时出现了一点问题到最后u盘还是启动不了。</p>
<p>有的iso文件带有setup可直接在系统中双击打开安装系统，不需要制作系统u盘</p>
<p>在安装双系统的时候个人感觉最好另开辟一个分区如linux的话20g就够用了，到时把linux系统装到这个盘中。linux系统有很多名字，ubuntu啊麒麟什么的可按自己的爱好选择，本质上都是linux系统，可能会有些许的指令不同。</p>
<p>先说一些问题，如果之后你想可以在window系统下选择启动哪个系统的话，你需要去网上找一些教程比如easybcd这个软件可以管理window启动项，easybcd推荐去官网下载，上边也有免费版的是针对个人发布的，但这里有一个坑，你需要看教程把linux系统的分盘做好，不然无法在easybcd下管理启动项。如果想在linux下引导系统，linux有自己的管理启动系统的工具，不需要重新安装，但是我的系统下window启动出现了一点问题，听说子啊linux下有一个修复启动的指令，如果遇问题就可以直接搜指令。但现在我还没有解决，就只能开机按f12的蛋疼操作了。</p>
<p>做好u盘之后重新启动，可能需要先关机在开始重启，在打开电源的时候疯狂按f2进入bios页面配置启动项找到你的u盘设置其优先级，不同的电脑或许会不同，我得电脑按f12也可以直接选择从哪个系统启动，之后就按照linux系统的提示一步步安装linux系统。</p>
<p>双系统其实没什么，不是什么高大上的东西，我现在才意识到这一点，而且在window下用vmware卡疯的我终于有了linux的系统体验，虽然现在还是补太会用，但比在虚拟机下好多了，现在才感觉装系统其实是一个及其简单的过程，而且就我现在看来，完全不必担心装系统给电脑装坏了，根本坏不了，只是需要保存一些要留的图片表格什么东西一类的，软件都可以再装，而且window10也有各种破解，所以如果想让电脑更快，重装系统把，如果被虚拟机搞崩溃了，就装双系统吧，一切都是这么简单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/27/双系统/" data-id="cj0rcx61m00011kuogt5ysixp" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-是什么？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/24/是什么？/" class="article-date">
  <time datetime="2017-03-24T01:29:15.454Z" itemprop="datePublished">2017-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/24/是什么？/">是什么？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>太长时间没有去思考，<br>太长时间没有去剖析自己，<br>太长时间又又没有去放空自己。<br>太多太多<br>或许有点迷茫<br>或许有点悲伤。</p>
<p>不知从何时开始，感觉自己也进入了迷茫期，有那么一段时间，什么都想做，还有那么一段时间，又什么都不想做，即使是玩游戏也提不起来精神，只是用来消磨时间的工具，内心不会有什么波澜，也不会觉得内心舒缓，但也不会觉得心里沉重，只是让自己有事可做。仅仅是有事可做而已。</p>
<p>很长时间没有像高中那样发呆看着窗外了，繁忙的时间的间隙偷一点懒放空自己看着窗外，发呆，发呆。有时会想一些事情，有时只是放空自己，让自己进入另一个世界，可能看起来很奇怪，但这一个时刻真的是心情很舒缓，全身心放松的那种愉悦，像找到了梦中桃花源的陶潜，自由自在，无忧无虑。现在想想忽然感觉自己接近了理解桃花源的世界。</p>
<p>不知道，不清楚，不明白，自己该想点什么，该做点什么。很多时候，找到了一个目标，很有热情去做，像孩子找到了宝贝一样欣喜，充满激情的投入了进去，可过了一段时间渐渐热情退却，或者说当自己要做的东西很简单做完了，就又陷入了一种反复的状态，不知道大家会不会都有相同的感受，反复的转换让人非常疲惫，渐渐地落入了一种无限的疲惫状态。在这样长时间的状态转换中，自己就在真假忙碌中度过，看似繁忙的日程，实则有大把的空闲时间来停下来想一想。是的，停下来想一想，就想高中那样的暂停，在繁忙的卷子中停一停，看一看天，看一看云，在晚上的时候出去溜达一圈，欣赏一下夜晚的世界，看花，看草，看世界，闻闻泥土的芳香，阳光的味道。是啊，有点累，为什么累?明明什么都没有做，凭什么说自己累。可是，我也不知道，不知道自己都在做一些什么，感觉什么都在做，却有感觉自己什么都做不好。</p>
<p>想有一段时间真的卸下一些包袱，放松一段时间，不是指待在寝室里无所事事，整日的打游戏什么之类的，在我看来有时这些事情会让我感觉更累，只是在浪费时间，想出行，想到一个新的地方去看一看，待在一个地方时间长了，会懒，不想动去别的地方，会厌，想离开这个地方。这很矛盾，可对我就这这样，我一直都生活在矛盾之中，一直一直。</p>
<p>也在想，自己进入大学之后就真的很少”聊天”了，很少很少，特别是到了最近，很想找人聊天，很想说什么，很想分享点什么，想离开机器离开学习的聊天，真心的聊天，想念曾经失去很久的聊天，想念曾经的分享，快乐或忧伤都好，想念小纸条的时光，那每次打开前的期待，打开之后的欣喜，发送出去时躲过老师时的偷乐，如同写信一般，期待，惊奇，欣喜。忘不掉曾经那段时光，打开一个纸条之前的那种惊奇，里边充满了惊喜，秘密，喜悦，悲伤，里边保存着记忆，我至今还完好的保存着曾经那么多的小纸条，如同曾经的那本日记本一样都是我保存的珍宝。</p>
<p>是不是也在期待能找到陪伴的那个人，找到那个一起看夜空的人，找到那个可以无话不谈的人，可以像个孩子一样一起玩的人，可能是变了，可能是怕了，可能是期待了，或许是在等吧。</p>
<p>就像这样的语无伦次，天马行空的狂写，也不知道自己在写什么，只是想到哪里就写到哪里，这样多好，一种混沌状态，不去想该做什么，不去想该想什么，不用想该组织什么，不存在逻辑，不存在组织，就是混沌。</p>
<p>想到了一句不疯魔不成活，想到了joker，想到了小丑，想到了混沌，想到自己为什么什么东西都做不好，或许就是我还不够疯狂，不够痴狂，不够混沌，不像小丑一样，不需要什么理由，就是为了让这个世界都疯狂。能到这个地步，我只是想做这个东西，就是想做好，以至于到了一种疯狂的偏执心理，无限混沌，没有逻辑，没有一切。</p>
<p>也不知在什么时候，很多事情都变了，曾经要好的朋友一点一点的失去了往日的感觉，或许只是矫情所致，远离的距离导致了心的隔阂越来越远，谈笑间没有了往日交谈的愉悦，很难想象，曾经的好友，如今像一个完全不认识的陌生人，有时的言语竟然也会杀死人，渐渐的感觉内心一种无法派遣的抑郁油然而生，原来所有人都是会变的，不能永远都做一个天真的人，距离会改变很多东西，而且有时也太高估了自己，过高估计了自己的价值，很多事情并不是平等对称的，在有些被我当作珍视之人的眼中，只是路人，人生旅途中匆匆的过客，如此简单，而这份落差，时间长了，有时才会被发现，就是这样。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/24/是什么？/" data-id="cj0rcx63s00061kuojlqel5qi" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-简单网络爬虫" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/21/简单网络爬虫/" class="article-date">
  <time datetime="2017-03-21T03:37:11.919Z" itemprop="datePublished">2017-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/21/简单网络爬虫/">java简单爬虫制作并爬取图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##简易爬虫制作</p>
<p>###什么是爬虫###<br>我现在对爬虫的印象只停留在可以爬取网页的内容，可以直接从网页中爬取链接，图片等有用的信息并分析他们。目前我做到的爬取的图片在我看来比直接访问的优势就在于如果想从网上下载很多图片，就可以直接爬取图片保存到本地，不用再一个一个访问后再下载。<br>想使用爬虫，</p>
<p>首先你要给它一个种子链接URL</p>
<p>在种子链接的页面查找其他的URL，重复1步骤</p>
<p>有链接有页面，然后你可以在页面中查找需要的内容</p>
<p>这其中需要的知识点</p>
<p>http请求器</p>
<p>由于不是用浏览器访问，我们需要在本地的文件中发起请求获取资源，有两种实现方法，第一种Java提供的java.net包中APIs，另一种是选用第三方的工具，我选的是HttpClient这个资源，相对来说第三方工具会比Java本身提供的APIs的功能更加强大和灵活一些。</p>
<p>内容解析器</p>
<p>上面我们通过请求获取了资源，然后就是要去解析了，基本上获取的都是页面，一大串的HTML页面代码，那么我们也可以通过来两种方式来解析资源，一种是正则表达式，一种是第三方的解析器(比如，jsoup，htmlparse等)，本系列会先使用正则表达式来解析，最后应该也会有第三方的解析文章。</p>
<p>主要的梗概大概就是这没多，我再来梳理总结一下</p>
<p>取一个种子URL，比如www.oschina.net</p>
<p>通过httpclient请求获取页面资源(获取的页面资源其中肯定包含了其他的URL，可以作为下一个种子循环使用)</p>
<p>通过正则或者jsoup解析出想要的内容(解析出其他的URL链接，同时获取本页面的所有图片，这都是可以的)</p>
<p>使用3获取的下一个种子URL，重复1</p>
<p>这就是关于爬虫的基本知识</p>
<p>##</p>
<p>###使用httpclient</p>
<p>我在学习的过程中使用的组件是httpclient,推荐到官网下载不会有什么乱七八糟的东西。官网地址：<a href="https://hc.apache.org/" target="_blank" rel="external">httpclient</a></p>
<p>httpclient使用步骤</p>
<blockquote>
<p>获取httpclient实例，实例获取是用静态方法获取的</p>
<blockquote>
<p>主要是使用HttpClients这个类的静态方法进行获取,即假装一个用户准备访问网页</p>
</blockquote>
<p>获取httpGet实例</p>
<blockquote>
<p>httpclient封装了http的各种方法，get只是其中一个，还有POST,HEAD之类的都可以,其中get，post，put，delete对应不同功能<br>get为请求查看，post创建，put是更新或创建，delete删除</p>
</blockquote>
<p>执行请求获取httpResponse响应</p>
<blockquote>
<p>执行就是httpclient实例execute httpget实例,即获取发送get请求之后的回复网页</p>
</blockquote>
<p>解析response响应的内容</p>
<blockquote>
<p>解析响应呢，有两种方法，一种是httpclient提供的httpentity实例解析的，还有一种是从输入流inputstream中获取，例子中是从inputstream中获取</p>
</blockquote>
<p>记得关闭资源，不要问为什么，这是一个好习惯，真要问为什么就是他会释放资源。</p>
</blockquote>
<p><em>代码如下</em><br>    package reptile;</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import org.apache.http.HttpEntity;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

public class HttpGetUtils {
    /**
     * get 方法
     * @param url
     * @return
     */
    public static String get(String url){
        String result = &quot;&quot;;
        try{
            //获取httpclient实例
            CloseableHttpClient httpclient = HttpClients.createDefault();
            //获取方法实例 GET方法  等于说获取get的消息准备发送给服务器
            HttpGet httpGet = new HttpGet(url);
            //执行方法得到响应 网页发送请求后会返回一个数据可以根据这个数据判断是否正确连接这个网页  这个response中有网页也有各种信息
            CloseableHttpResponse response = httpclient.execute(httpGet);
            try{
                //如果正确执行而且返回值正确即可解析
                if(response != null 
                        &amp;&amp; response.getStatusLine().getStatusCode() == HttpStatus.SC_OK){
                    System.out.println(response.getStatusLine());
                    HttpEntity entity = response.getEntity();
                    //从输入流中解析结果  utf-8 为这个标准的字符集
                    result = readResponse(entity,&quot;utf-8&quot;);

                }
            }finally{
                response.close();
                httpclient.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }


        return result;
    }
    /**
     * 解析网页的方法
     * @param entity
     * @param string
     * @return
     */
    private static String readResponse(HttpEntity resEntity, String charset) {
        StringBuffer res = new StringBuffer();
        BufferedReader reader = null;
        try{
            if(resEntity == null){
                return null;
            }

            reader = new BufferedReader(new InputStreamReader(resEntity.getContent(), charset));
            String line = null;

            while((line = reader.readLine()) != null){
                res.append(line);
            }

        }catch(Exception e){
            e.printStackTrace();
        }finally{
            try{
                if(reader!=null){
                    reader.close();
                }
            }catch(IOException e){

            }
        }

        return res.toString();
    }


}
</code></pre><p>这样我们就能够获取一个网页的内容了，之后我们需要解析这个网页从中获取你想要的内容</p>
<p>##</p>
<p>###正则表达式###<br>正则表达式如同printf里的格式一般可以识别特定的内容，不过他有自己特定的语法，详细的语法说明请看<a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="external">runoob.com</a>或者<a href="http://www.cnblogs.com/ITtangtang/archive/2012/05/01/2478061.html" target="_blank" rel="external">blog</a>这两个会有很多帮助<br>在这里列一些简答的语法<br>    元字符</p>
<pre><code>\b 用于单词的间隙处，\bhello\b表示匹配hello单词

\d 匹配数字 0\d\d 表示匹配011,023，以0开头三位数字，还可以写成0\d{2}，0后面两个数字

.  匹配换行符以外的所有字符

* 它前面的字符可以无限重复

\s 任意的空白符 ，比如空格，TAB

\w 字母或数字或下划线或汉字等

+ 和*类似，但是+至少一次，*可能0此

^ 字符串开始

$ 字符串结束

{5,12} 长度限制在5到12之间

？ 重复0到1次

[ ] 表示需要查找的内容，比如[aeiou]包含元音字母，[.?*]包含.?*的串

字符转义

用 \ 来转义元字符，比如要查找含*的串，\* == *

分支条件

| 表示或，两个表达式连接 a|b，表示满足表达式a或者b

分组

（）分组，可以把多个匹配放到一块，重复查找

反义

\W\S\D\B把小写改成大写，[]里的加^，比如[^aeiou]不是元音字母

注释

(?#comment) 对表达式进行注释，比如 2\d[0-2](?#200-292)   表示200-292之间的数字

贪婪与懒惰

a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

在 . * ？ {n,m}等后面加？则表示尽可能少的匹配，.? *? ?? {n,m}?

可能你看了上面还是不知道在说什么不要紧，下面写了java的正则API之后会举例说明
</code></pre><p>语法这些东西是需要好好理解的，个人认为我在写爬虫最大的问题就是正则表达式的书写，虽然可以直接找相关的工具。。。</p>
<p>在百度的网页按f12找如下的图示<br><img src="/images/logo.png" alt=""></p>
<p>接下来是一个实例</p>
<pre><code>group是在使用matcher的时候如果正则表达式带有（）他会把匹配的括号里的内容放到group（1）里而原字符串放在group（0）

使用的流程可以分为下面几个步骤

Pattern的compile静态方法获取pattern对象

pattern调用自身的matcher方法返回Matcher对象matcher

matcher对象通过find，matches，lookingAt等方法进行匹配

package reptile;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexStringUtils {

    public static String regexString(String targetStr,String patternStr){
        //编辑正则表达式
        Pattern pattern = Pattern.compile(patternStr);
        //定义一个matcher来做匹配
        Matcher matcher = pattern.matcher(targetStr);
        //int i=209;//这个是后续的时候为了下载图片要给他定义不同的名字到后续DownloadUtils的时候才有用
        //如果能匹配到
        if(matcher.find()){
            //打印结果
            System.out.println(&quot;find it.&quot;);
            //DownloadUtils.get(matcher.group(1),i);
            //i++;
            return matcher.group(0);
        }
        return &quot;&quot;;
    }
}
</code></pre><p>这样子之后我们就需要定义一个main方法来实现这些操作<br>    package reptile;</p>
<pre><code>public class App {
    public static void main(String[] args){
        //不同网页可能会有不同的标签
        String regex = &quot;src=\&quot;http://([\\w[./#_-]]+)\&quot;&quot;;
        System.out.println(regex);

        String result = HttpGetUtils.get(url);

//        String result = DownloadUtils.get(url);
        System.out.println(result);
        String src = RegexStringUtils.regexString(result, regex);
         System.out.println(src);
    }
}
</code></pre><p>大概输出结果是这样</p>
<pre><code>hidefocus.+?src=&quot;//(.+?)&quot;
HTTP/1.1 200 OK
&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;.....中间的就省略了&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
www.baidu.com/img/bd_logo1.png
</code></pre><p>最后我们就需要把找到的图片给下载下来，这时需要用到流式操作，具体如果操作请自行学习，最好能够下载下来java的api，上边有各种类的定义与方法说明</p>
<p>最后的类</p>
<pre><code>package reptile;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;

import org.apache.http.HttpEntity;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

public class DownloadUtils {

    public static String get(String url,int i){

        String filename = &quot;&quot;;
        String tergetUrl = &quot;http://&quot;+url;
        try{
            CloseableHttpClient httpclient = HttpClients.createDefault();
            HttpGet httpGet = new HttpGet(tergetUrl);
            CloseableHttpResponse response = httpclient.execute(httpGet);

            try{
                //同意请求
                if(response != null 
                        &amp;&amp; response.getStatusLine().getStatusCode()==HttpStatus.SC_OK){
                    System.out.println(response.getStatusLine());;
                    HttpEntity entity = response.getEntity();
                    filename = download(entity,i);

                }
            }finally{
                httpclient.close();
                response.close();
            }


        }catch(Exception e){
            e.printStackTrace();
        }

        return filename;
    }

    private static String download(HttpEntity resEntity,int i) {
        //保存路径    
        String dirPath = &quot;d:\\img\\&quot;;
        //图片名称
        String fileName = &quot;sssss&quot;+i+&quot;.png&quot;;
        //如果没有先创建目录
        File file = new File(dirPath);
        if(file == null || !file.exists()){
            file.mkdirs();
        }
        //确定完整目录
        String realPath = dirPath.concat(fileName);
        File filePath = new File(realPath);
        if(file == null || !filePath.exists()){
            try{
                filePath.createNewFile();
            }catch(IOException e){
                e.printStackTrace();
            }
        }

        //得到输入流，把输入流放入缓冲区，从缓冲区读取flush，关闭资源
        BufferedOutputStream bos = null;
        InputStream is = null;
        try{
            if(resEntity == null){
                return null;
            }
            is = resEntity.getContent();
            bos = new BufferedOutputStream(new FileOutputStream(filePath));
            byte[] bytes = new byte[1024];
            int len=-1;
            while((len = is.read(bytes))!=-1){
                bos.write(bytes,0,len);
            }
            bos.flush();
            bos.close();
        }catch(IOException e){
            e.printStackTrace();
        }finally{
            try{
                if(is!=null){
                    is.close();
                }
            }catch(IOException e){
                e.printStackTrace();
            }
        }


        return filePath.toString();
    }
}
</code></pre><p>如果成功的话你就可以看到你保存的图片了，之后你就可以爬任何你想要的网页上的图片了，中间遇到一个问题，有些带有hide标签的网页在爬取的过程中爬不到东西，这个问题还需要深入研究。好了这篇文章就这样结束了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/21/简单网络爬虫/" data-id="cj0rcx62x00041kuoyjitgw0u" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-制作自己的qq机器人" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/制作自己的qq机器人/" class="article-date">
  <time datetime="2017-03-19T08:08:58.035Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/制作自己的qq机器人/">实现自己的qq机器人</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现自己的qq机器人<br>需要python环境配置<br><a href="https://github.com/pandolia/qqbot" target="_blank" rel="external">https://github.com/pandolia/qqbot</a>   到该网址下下载qqbot安装<br>推荐在linux下使用会比较方便安装python等比较简单，win下安装完python环境之后需要再配置python环境，具体操作看网上教程</p>
<p>QQBOT<br>一、介绍</p>
<p>QQBot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的简单 QQ 机器人，可运行在 Linux 、 Windows 和 Mac OSX 平台下。</p>
<p>本项目 github 地址： <a href="https://github.com/pandolia/qqbot" target="_blank" rel="external">https://github.com/pandolia/qqbot</a></p>
<p>你可以通过扩展 QQBot 来实现：</p>
<p>监控、收集 QQ 消息<br>自动消息推送<br>聊天机器人<br>通过 QQ 远程控制你的设备<br>二、安装方法</p>
<p>在 Python 2.7/3.4/3.5 下使用，用 pip 安装，安装命令：</p>
<p>$ pip install qqbot<br>三、使用方法</p>
<ol>
<li>启动 QQBot</li>
</ol>
<p>在命令行输入： qqbot 。启动过程中会自动弹出二维码图片，需要用手机 QQ 客户端扫码并授权登录。启动成功后，会将本次登录信息保存到本地文件中，下次启动时，可以输入： qqbot -q qq号码 ，先尝试从本地文件中恢复登录信息（不需要手动扫码），只有恢复不成功或登录信息已过期时才会需要手动扫码登录。一般来说，保存的登录信息将在 2 ~ 3 天之后过期。</p>
<p>注意： Linux 下，需要系统中有 gvfs-open 或者 shotwell 命令才能自动弹出二维码图片（一般安装有 GNOME 虚拟文件系统 gvfs 的系统中都会含这两个命令之一）。 Windows10 下，需要系统中已设置了 png 图片文件的默认打开程序才能自动弹出二维码图片。</p>
<p>若系统无法自动弹出二维码图片，可以手动打开图片文件进行扫码，也可以将二维码显示模式设置为邮箱模式或服务器模式进行远程扫码，详见本文档的第六节。</p>
<ol>
<li>操作 QQBot</li>
</ol>
<p>QQBot 启动后，在另一个控制台窗口使用 qq 命令来操作 QQBot ，目前提供以下命令：</p>
<p>1） 帮助<br>    qq help</p>
<p>2） 列出所有 好友/群/讨论组<br>    qq list buddy|group|discuss</p>
<p>3） 向 好友/群/讨论组 发送消息<br>    qq send buddy|group|discuss x|uin=x|qq=x|name=x|nick=x|mark=x message</p>
<p>4） 获取 好友/群/讨论组 的信息<br>    qq get buddy|group|discuss x|uin=x|qq=x|name=x|nick=x|mark=x</p>
<p>5) 获取 群/讨论组 的成员<br>    qq member group|discuss x|uin=x|qq=x|name=x|mark=x</p>
<p>6） 停止 QQBot<br>    qq stop</p>
<p>7） 重启 QQBot （需要手工扫码登陆）<br>    qq restart<br>在 send/get/member 命令中，第三个参数可以是 好友/群/讨论组 的 名称/昵称/备注名/qq/uin 。</p>
<p>QQBot 启动后，用另外一个 QQ 向本 QQ 发送 “–version” ，则 QQBot 会自动回复： “QQBot-v2.x.x” 。（注：2.0.3之前的版本中，通过 QQ 消息发送以上 6 个命令也可以操作 QQBot , 2.0.4 版之后，为安全起见，去掉此功能，只保留一个 “–version” 的命令用来远程测试 QQBot 是否正常运行）。</p>
<p>四、实现你自己的 QQ 机器人</p>
<p>实现自己的 QQ 机器人非常简单，只需要生成一个 QQBot 对象并为其注册一个消息响应函数。示例代码：</p>
<p>from qqbot import QQBot</p>
<p>myqqbot = QQBot()</p>
<p>@myqqbot.On(‘qqmessage’)<br>def handler(bot, message):<br>    if message.content == ‘-hello’:<br>        bot.SendTo(message.contact, ‘你好，我是QQ机器人’)<br>    elif message.content == ‘-stop’:<br>        bot.SendTo(message.contact, ‘QQ机器人已关闭’)<br>        bot.Stop()</p>
<p>myqqbot.LoginAndRun()<br>以上代码运行后，用另外一个 QQ 向本 QQ 发送消息 “-hello”，则会自动回复 “你好，我是 QQ 机器人”，发送消息 “-stop” 则会关闭 QQ 机器人。</p>
<p>QQBot 对象收到一条 QQ 消息时，会新建一个 QQMessage 对象，之后将这个 QQMessage 对象以及自身传递给消息响应函数。</p>
<p>消息响应函数中的第一个参数为传递来的 QQBot 对象，也就是 myqqbot ，第二个参数是传递来的 QQMessage 对象，该对象主要有以下四个属性：</p>
<p>message.contact    ： QContact对象，消息发送者<br>message.memberUin  ： str 对象，消息发送成员的 uin，仅在该消息为 群/讨论组 消息时有效<br>message.memberName ： str 对象，消息发送成员的昵称，仅在该消息为 群/讨论组 消息时有效<br>message.content    ： str 对象，消息内容<br>QQMessage 对象还提供一个 Reply 接口，可以给消息发送者回复消息，如：</p>
<p>message.Reply(‘你好，我是QQ机器人’) # 相当于 bot.SendTo(message.contact, ‘你好，我是QQ机器人’)<br>message.contact 是一个 QContact 对象，该对象有以下属性：</p>
<p>contact.ctype    : str 对象，联系人类型，可以为 ‘buddy’, ‘group’, ‘discuss’ ，代表 好友/群/讨论组<br>contact.uin      : str 对象，联系人的 uin ，底层发消息要使用本数值，每次登录本数值可能会改变<br>contact.qq       : str 对象，联系人的 qq<br>contact.name     : str 对象，联系人的名称<br>contact.nick     : str 对象，好友的昵称<br>contact.mark     : str 对象，好友或群的备注名<br>contact.members  : dict 对象，群或讨论组的成员字典<br>还提供一个 GetMemberName 接口，可以通过成员的 uin 查询成员的网名：</p>
<p>contact.GetMemberName(memberUin) –&gt; memberName, str object<br>五、 QQBot 对象的接口</p>
<p>QQBot 对象调用其 Login 方法登录成功后，提供 List/Get/SendTo/Send/On 五个接口，一般来说，只需要调用这五个接口就可以了，不必关心 QQBot 的内部细节。</p>
<p>（1） bot.List(ctype) –&gt; [contact0, contact1, …, ]</p>
<p>对应上面的 list 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.List(‘buddy’)<br>bot.List(‘group’)<br>bot.List(‘discuss’)<br>…<br>返回一个联系人对象（QContact对象）列表。</p>
</blockquote>
</blockquote>
</blockquote>
<p>（2） bot.Get(ctype, <em>args, *</em>kwargs) –&gt; [contact0, contact1, …, ]</p>
<p>对应上面的 get 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.Get(‘buddy’, ‘jack’)<br>bot.Get(‘group’, ‘1234556’)<br>bot.Get(‘buddy’, ‘qq=1235778’)<br>bot.Get(‘buddy’, uin=’1234768’)<br>bot.Get(‘discuss’, name=’disc-name’)<br>bot.Get(‘buddy’, mark=’jack’)<br>第二个参数可以为联系人的 名称/昵称/备注名/qq/uin ，注意，这里返回的是一个 QContact 对象的列表，而不是返回一个 QContact 对象。</p>
</blockquote>
</blockquote>
</blockquote>
<p>（3） bot.SendTo(contact, content) –&gt; ‘向 xx 发消息成功’</p>
<p>向联系人发送消息。第一个参数为 QContact 对象，一般通过 Get 接口得到，第二个参数为消息内容。</p>
<p>（4） bot.Send(ctype, <em>args, *</em>kwargs) –&gt; [‘向 xx 发消息成功’, ‘向 xx 发消息成功…’, …, ]</p>
<p>对应上面的 send 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.Send(‘buddy’, ‘jack’, ‘hello’)<br>bot.Send(‘group’, ‘1234556’, ‘hello’)<br>bot.Send(‘buddy’, ‘qq=1235778’, ‘hello’)<br>bot.Send(‘buddy’, uin=’1234768’, content=’hello’)<br>bot.Send(‘discuss’, name=’disc-name’, content=’hello’)<br>Send 接口的第一、二个参数和 Get 接口的一样，第三个参数为消息内容。上面的第一条语句相当于：</p>
</blockquote>
</blockquote>
</blockquote>
<p>result = []<br>for contact in bot.Get(‘buddy’, ‘jack’):<br>    result.append(bot.SendTo(contact, ‘hello’))<br>return result<br>（5） bot.On(mtype, callback) –&gt; callback</p>
<p>注册消息响应函数。第一个参数 mtype 为需要响应的消息的类型，一般来说，只需要响应 QQ 消息和 qterm 客户端消息， mtype 分别为 ‘qqmessage’ 和 ‘termmessage’ 。第二个参数 callback 为消息响应函数。</p>
<p>当 QQBot 收到这两种消息时，会新建一个 QQMessage 对象或 TermMessage 对象，连同 QQBot 对象本身一起传递给 callback 。这两种消息对象都有 content 属性和 Reply 接口，content 代表消息内容， Reply 接口可以向消息的发送者回复消息，对于 TermMessage 对象，消息发送者就是 qterm 客户端，注意，对于所有 TermMessage ，都必须调用一次 Reply ，否则 qterm 客户端会一直等待此回复消息。</p>
<p>六、二维码管理器、QQBot 配置、掉线后自动重启、命令行参数</p>
<p>SmartQQ 登录时需要用手机 QQ 扫描二维码图片，在 QQBot 中，二维码图片可以通过以下三种模式显示：</p>
<p>GUI模式： 在 GUI 界面中自动弹出二维码图片<br>邮箱模式： 将二维码图片发送到指定的邮箱<br>服务器模式： 在一个 HTTP 服务器中显示二维码图片<br>GUI 模式是默认的模式，只适用于个人电脑。邮箱模式可以适用于个人电脑和远程服务器。服务器模式一般只在有公网ip的系统中使用。最方便的是使用 QQ 邮箱的邮箱模式，当发送二维码图片后，手机 QQ 客户端一般会立即收到通知，在手机 QQ 客户端上打开邮件，再长按二维码就可以扫描了。</p>
<p>注意：当开启了邮箱模式或服务器模式时， GUI 模式是关闭的，登陆时不会自动弹出二维码图片。</p>
<p>每次登录时会创建一个二维码管理器 （QrcodeManager 对象） ，二维码管理器会根据配置文件及命令行参数来选择二维码图片的显示方式。</p>
<p>配置文件为 ~/.qqbot-tmp/v2.x.conf ，第一次运行 QQBot 后就会自动创建这个配置文件，其中内容如下：</p>
<p>{</p>
<pre><code># QQBot 的配置文件

# 用户 somebody 的配置
&quot;somebody&quot; : {

    # QQBot-term 服务器端口号
    &quot;termServerPort&quot; : 8188,

    # http 服务器 ip，请设置为空字符串或公网 ip
    &quot;httpServerIP&quot; : &quot;127.0.0.1&quot;,

    # http 服务器端口号
    &quot;httpServerPort&quot; : 8189,

    # 自动登录的 QQ 号
    &quot;qq&quot; : &quot;3497303033&quot;,

    # 接收二维码图片的邮箱账号
    &quot;mailAccount&quot; : &quot;3497303033@qq.com&quot;,

    # 该邮箱的 IMAP/SMTP 服务授权码
    &quot;mailAuthCode&quot; : &quot;feregfgftrasdsew&quot;,

    # 显示/关闭调试信息
    &quot;debug&quot; : False,

    # QQBot 掉线后自动重启
    &quot;restartOnOffline&quot; : False,

},

# 请勿修改本项中的设置
&quot;默认配置&quot; : {
    &quot;termServerPort&quot; : 8188,
    &quot;httpServerIP&quot; : &quot;&quot;,
    &quot;httpServerPort&quot; : 8189,
    &quot;qq&quot; : &quot;&quot;,
    &quot;mailAccount&quot; : &quot;&quot;,
    &quot;mailAuthCode&quot; : &quot;&quot;,
    &quot;debug&quot; : False,
    &quot;restartOnOffline&quot; : False,
},
</code></pre><p>}<br>如果需要使用邮箱模式，可以在配置文件中新增一个用户配置（如 somebody ），在该用户下的 mailAccount 和 mailAuthCode 项中分别设置邮箱帐号和授权码，启动 QQBot 时，输入 qqbot -u somebody ，开始运行后，二维码管理器会将二维码图片发送至该邮箱。</p>
<p>注意：授权码不是邮箱的登录密码，而是邮箱服务商提供的开通 IMAP/SMTP 服务的授权码， QQ 邮箱可以在网页版的邮箱设置里面开通此项服务，并得到授权码。如果只定义了 mailAccount 而没定义 mailAuthCode ，则程序运行的开始时会要求手工输入此授权码。</p>
<p>由于网易的邮箱对 IMAP 协议的支持非常有限，无法在 QQBot 中使用。 QQ 的邮箱已通过测试，其他服务商的邮箱还未测试过，因此建议还是使用 QQ 邮箱。</p>
<p>如果需要使用服务器模式，可以配置 httpServerIP 和 httpServerPort 项，一般来说应该设置为公网 ip 。服务器模式开启后，可以通过 <a href="http://httpServerIP:httpServerPort/qqbot/qrcode" target="_blank" rel="external">http://httpServerIP:httpServerPort/qqbot/qrcode</a> 来访问二维码图片。</p>
<p>当邮箱模式和服务器模式同时开启时，发邮件时不会发送真正的图片，只会将图片地址发到邮箱中去，而且只发送一次，二维码过期时刷新一下邮件就可以了。如果只开启邮箱模式，则发邮件时会发送真正的图片，当二维码过期时，需要手动将邮件删除，删除之后才会发送最新的二维码图片。</p>
<p>配置文件中每个用户都有 qq 这一项，如果在某用户（如 somebody ）下设置了此项，则在命令行中输入 qqbot -u somebody 启动后，会先使用此 QQ 号上次登录保存的登录信息来自动登录。</p>
<p>如果配置文件中将 restartOnOffline 项设置为 True ，则当 QQBot 掉线或出错终止时，会自动重新启动 QQBot 。</p>
<p>配置文件中的所有选项都有对应的命令行参数，在命令行参数中输入的选项优先级比配置文件高。输入 qqbot -h 可查看所有命令行参数格式。</p>
<p>如果配置的 QQBot-term 服务器端口号不是默认的 8188 ，那么在运行 qterm 或 qq 命令时，需要在第一个参数中指定端口号，如：</p>
<p>$ qterm 8100<br>$ qq 8100 send buddy jack hello<br>$ qq 8100 member group chatbot</p>
<p>转载自github pandolia</p>
<p>至此qqbot安装与检测完成<br>接下来需要写一个python小程序来响应响应的输入与输出<br>在此之前需要现在图灵机器人网站注册账号新建一个机器人配置完成后并获取API地址，API key，<br><img src="/images/xiaoying.png" alt=""><br>可进行测试例如api地址=www.ro<strong><em>.com省略<br>api key = 4321532<br>输入网址可进行测试<br>例：www.ro</em></strong>.com？key=4321532&amp;info=你是谁<br>如果实现成功会在在网页上看到网页的回复，回复是一个json，至于什么是json自行百度<br>如果这些已经完成就可以进入最后一步了<br>如下已实现的代码</p>
<p>from qqbot import QQBot<br>import urllib<br>import urllib2<br>import cookielib<br>import json<br>import sys<br>reload(sys)<br>sys.setdefaultencoding(‘utf-8’)</p>
<p>#cookie = cookielib.CookieJar()<br>opener = urllib2.build_opener()<br>url = ‘www.ro<em>*</em>.com？key=4321532&amp;info=’<br>opener.addheaders = [(‘User-agent’, ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:47.0) Gecko/20100101 Firefox/47.0’)]<br>myqqbot = QQBot()</p>
<p>@myqqbot.On(‘qqmessage’)<br>def handler(bot, message):<br>    reply = opener.open(url+message.content)<br>    str = reply.read()<br>    data = json.loads(str)<br>    bot.SendTo(message.contact, data[“text”].decode(“utf8”))<br>    if message.content == ‘-stop’:<br>        bot.SendTo(message.contact, ‘QQ机器人已关闭’)<br>        bot.Stop()<br>        conn.close()</p>
<p>myqqbot.LoginAndRun()</p>
<p>运行上述代码并扫码登陆之后就可以实现你自己的机器人了，想要动手的就立即执行把。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/制作自己的qq机器人/" data-id="cj0rcx62200031kuod2hl3a14" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-制作自己的博客并上传" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/制作自己的博客并上传/" class="article-date">
  <time datetime="2017-03-19T07:49:41.806Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/制作自己的博客并上传/">制作自己的博客并上传</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用hexo搭建博客并上传GitHub<br>之前在博客园、简书、CSDN等地儿都开过博，一篇文章写好了，我希望能在几个平台可以同步发布，可是操作起来成本不低。几个平台下的富文本编辑器比较起来还是博客园更顺手，看着更舒服，尤其是代码块的操作灵活、准确。而CSDN对代码块内的文字加粗、修改字色后就会出现html文无法解析的情况，混杂着代码和html文本实在太难看了，后来我知道原来是Markdown的代码块规则限制。而且CSDN刚刚才取消了提交文章要审核通过才能发布的限制，审核没有完成之前，连自己都看不到，且不能修改，这让我一度放弃CSDN平台。如果是写普通的文章写作体验最好的是简书，大气、简洁。但简书更适合一般的写作，比较技术化的中间掺杂大量代码的支持还不够好。</p>
<p>作为一名程序员，应该到GitHub上开博，这里是程序员的圣城。花了两天时间研究了一下，发现还蛮简单的，而且md格式也被博客园、简书、CSDN所支持，写完一份应该比较容易复制到这三个平台。我喜欢在本地编辑markdown文件，使用sublime 及其插件Markdown Editing 和 OmniMarkupPreviewer。完成后底稿、资源文件都悉数保存到GitHub，日后查找、修改都很容易。</p>
<p>我用hexo作为静态页面生成器，操作过程遇到不少问题，搞定之后留一份操作记录吧。以后就把[<a href="http://palanceli.github.io/blog/]作为我的首发平台了" target="_blank" rel="external">http://palanceli.github.io/blog/]作为我的首发平台了</a>;)</p>
<p>安装环境<br>安装node.js，去官网下载安装即可，我安装的是最新稳定版。<br>安装Hexo<br>sudo npm install -g hexo</p>
<p>创建hexo目录并初始化</p>
<p>$ mkdir hexo<br>$ cd hexo<br>$ hexo init<br>然后就可以生成网站，启动服务了：</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>hexo文件夹<br>先来看一下hexo文件夹下的内容：</p>
<p>hexo/<br>  |- node_modules/  # hexo需要的模块，不需要上传GitHub<br>  |- themes/        # 主题文件，需要上传GitHub的dev分支<br>  |- sources/       # 博文md文件，需要上传GitHub的dev分支<br>  |- public/        # 生成的静态页面，由hexo deploy自动上传到gh-page分支<br>  |- package.json   # 记录hexo需要的包信息，不需要上传GitHub<br>  |- _config.yml    # 全局配置文件，需要上传GitHub的dev分支<br>  |- .gitignore     # hexo生成默认的.gitignore，它已经配置好了不需要上传的hexo文件<br>关联GitHub<br>首次先创建GitHub工程blog，并且使用“Launch automatic page generator”生成页面，它会给该工程创建分支gh-pages。<br>手动为之创建dev分支，未来工程源码会放到dev分支下；hexo生成的网站静态页面会放到gh-pages分支。</p>
<p>首次创建GitHub工程后操作dev分支代码<br>如果是刚创建的GitHub工程，clone dev分支的代码到本地blog-dev/，然后把前面hexo/文件夹下的内容全部拷贝到blog-dev/，注意包括一个隐藏文件.gitignore。</p>
<p>已存在GitHub工程的恢复<br>仍是clone dev分支的代码到本地blog-dev/，然后把hexo/node_modules/拷贝到blog-dev/<br>再试试生成页面、启动服务，确保是正常的：</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>网上有介绍把package.json文件同步到GitHub，以后每次恢复时执行</p>
<p>$ npm install hexo<br>$ npm install<br>$ npm install hexo-deployer-git –save<br>可是我在不同的机器上试总是出错。只好采取笨办法，每次先hexo init出一个完整文件夹，再把相关文件拷贝到GitHub目录下。千万不要先clone 了blog目录，再在该目录下执行hexo init，因为init会把.git信息删掉。</p>
<p>配置自己的_config.yml<br>按照如下内容修改blog-dev/_config.yml：</p>
<p>title: Palance’s Blog   # 标题<br>subtitle:<br>description:<br>author: Palance Li<br>language: zh-CN         # 语言设置<br>url: <a href="http://palanceli.github.io/blog" target="_blank" rel="external">http://palanceli.github.io/blog</a><br>root: /blog/<br>翻到最下面，改成：</p>
<p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>&lt;自己的github账号&gt;/blog.git<br>  branch: gh-pages<br>主题<br>这里有大量的主题<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/hexojs/hexo/wiki/Themes</a><br>我非常喜欢Maupassant：<a href="https://www.haomwei.com/technology/maupassant-hexo.html，" target="_blank" rel="external">https://www.haomwei.com/technology/maupassant-hexo.html，</a><br>简洁清晰，而且适配手机、PC各个平台。</p>
<p>安装方法<br>首次在blog-dev/目录下执行如下命令</p>
<p>$ git clone <a href="https://github.com/tufu9441/maupassant-hexo.git" target="_blank" rel="external">https://github.com/tufu9441/maupassant-hexo.git</a> themes/maupassant<br>$ npm install hexo-renderer-jade –save<br>$ npm install hexo-renderer-sass –save<br>以后建议把blog-dev/themes/maupassant/.git文件夹删掉，把maupassant文件夹随自己的blog-dev上传到GitHub。<br>以后clone blog-dev后，执行完前面的安装操作步骤后记得执行</p>
<p>$ npm install hexo-renderer-jade –save<br>$ npm install hexo-renderer-sass –save<br>配置<br>在blog-dev/themes/maupassant/_config.yml中根据自己的情况修改，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">links:</div><div class="line">title: 我的博客园</div><div class="line">url: http://www.cnblogs.com/palance/</div><div class="line">title: 我的CSDN</div><div class="line">url: http://blog.csdn.net/zchongr</div><div class="line">title: 我的简书</div><div class="line">url: http://www.jianshu.com/users/5e527164a8c2</div><div class="line"></div><div class="line">在blog-dev/_config.yml中修改:</div><div class="line">theme: maupassant</div></pre></td></tr></table></figure></p>
<p>第一次的工作就完成了，可以提交github到blog-dev了。</p>
<p>上传生成页面<br>执行</p>
<p>$ cd blog-dev<br>$ npm install hexo-deployer-git<br>以后每次执行完</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>生成了静态页面后就可以执行</p>
<p>hexo deploy<br>完成页面上传。</p>
<p>其它<br>图片<br>首先确认_config.yml中有：</p>
<p>post_asset_folder: true<br>然后在blog-dev/下执行</p>
<p>npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">https://github.com/CodeFalling/hexo-asset-image</a> –save<br>确保在blog-dev/source/_posts下创建和md文件同名的目录，在里面放该md需要的图片，然后在md中插入</p>
<p><img src="目录名/文件名.png" alt=""><br>即可在hexo generate时正确生成插入图片。比如：</p>
<p><em>posts<br>    |- post1.md<br>    |</em> post1<br>        |- pic1.png<br>在md文件中插入图片时只需写</p>
<p><img src="post1/pic1.png" alt=""><br>即可。首次配置完了需要执行一次清除操作，再生成页面：</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>如果没做清除，直接生成页面，在我这里会出现路径错误的情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/制作自己的博客并上传/" data-id="cj0rcx63d00051kuotg8dp4qq" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-once_study" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/once_study/" class="article-date">
  <time datetime="2017-03-18T12:01:43.519Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/once_study/">once_study</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【TCP/IP协议】<br>之前有看过过关于TCP/IP协议的书籍，所以这次再次看tcp/ip协议相关的东西还是有一点熟悉的，但是由于当时看只是为了大致了解一下计算机网络的构造是怎么样的所以当时就没没有更加细致的了解相关的内容，再次接触的时候相对于之前了解的东西更多了一点，tcp/ip协议包括一系列的协议，不同的协议保证不同功能的传输，如tcp协议主要是用于应用程序之间的通讯，而ip协议主要用于计算机之间的通讯，之后介绍的相关的一些名词我大致可以理解如“握手”我个人理解是相当于连接的概念。<br>但是我保留了一个问题，介绍中所说的“这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。“，我不是特别明白这个通讯线路指的是什么，按前边与后边的介绍，tcp协议主要负责的是程序间的通讯，把程序要发送的数据包装成ip报的形式通过ip协议发送出去，按照我的理解tcp协议占用计算机本机高层通道使电脑的高层程序的数据能够发送，是这个通道被解释为两个计算机间的通讯线路还是另有其他的东西。<br>还有就是关于ip协议，计算机的网卡会有一个单独的48位mac地址，而计算机接入网络的时候又会分配一个32位的ip地址，我在搜索相关知识之后感觉对到底是ip寻址还是mac地址寻址产生了 混乱的理解，如下搜到的一段关于mac地址的知识：<br>数据包在这些节点之间的移动都是由ARP负责将IP地址映射到MAC地址上来完成的。其实人类社会和网络也是类似的，试想在人际关系网络中，甲要捎个口信给丁，就会通过乙和丙中转一下，最后由丙 转告给丁。在网络中，这个口信就好比是一个网络中的一个数据包。数据包在传送过程中会不断询问相邻节点的MAC地址，这个过程就好比是人类社会的口信传送过程。相信通过这两个例子，我们就可以进一步理解MAC地址的作用。</p>
<p>所以在网络中到底是直接对ip地址寻址找到ip对应即找到要发送方，还是通过ip找到对应的路由器再由路由器查询其mac地址的表格发送ip包，我对这点有点疑问。<br>【PHP】</p>
<p>PHP基础<br>在了解了一些PHP基础的知识之后发现其实大部分的基础都c，java这些语言差不多包括函数的定义，分支结构，循环结构等大部分基础的操作可以直接从其他语言基础转移，有一些不同之处在于：</p>
<ol>
<li>一些特别的函数名称不太相同如输出语句即可以用print也可以用echo进行输出.</li>
<li>但相当其他语言对数据的定义来说，PHP对数据的定义并没有那么的严格，而且有很多种类型的数据都可以按照字符串来定义，神奇的是我发现PHP语言对字符串的理解能力很强，在很多情况下他可以直接从字符串里边读出整数等，可以将特定的数据从字符串中分离出来而不像c和java这种语言字符串就是字符串.</li>
<li>特别的PHP的逻辑运算符还有一个全等的比较，由于PHP对符号的应用比较多对字符串的识别能力也很强大如“100”=100，但是比较还有一个全等的比较那样只有数值相等并且数据类型相同才返回真值。</li>
<li>PHP数组的功能也比较全，吸取了map，set等的思想，数组定义不仅可以定义以数字为索引的数组，还可以定义以自定义字符索引的数组，相当于一个map</li>
<li>字符串的相关函数有很多，熟悉之后可以熟悉相关的功能。</li>
<li>PHP有一种独特的数据类型，超全局变量，对于超全局变量我的理解还没有太全，我现在的理解是他是PHP语言定义的一类存储相关的特别数据的一类数据，通过访问这些全局变量数组的值可以返回特定的数据，如SERVER可以返回关于脚本的信息。但由于我对脚本的理解比较少，所以我对讲解所说的脚本这些东西没有什么概念，我现在的理解是脚本是程序但不知道他被称为脚本的原因。</li>
</ol>
<p>PHP表格<br>由于我是先看的PHP之前没有看相关的HTML语言的相关知识的积累所以对页面中的实例的理解不是特别到位</p>
<ol>
<li>首先我对HTML的表单的一些知识有一些大致的了解但不是特别深入，例如：<br>Name: <input type="text" name="name"><br>E-mail: <input type="text" name="email"><br>Website: <input type="text" name="website"><br>Comment: <textarea name="comment" rows="5" cols="40"></textarea><br>这段代码中我的大致的理解是input 相当与一类声明表示输入模式，  type name这些都是特殊的字符串名称有特定的意义，不是编程用户定义的内容。</li>
<li>在表单的处理中 action方法是用户自己的PHP代码用于实现相关的功能，method=port 或 get重，这是会用到超全局变量，我是这样理解的，method的这两个东西会将数据保存到超全局变量中去，编程者可以从那些变量中获取到数据。而且在获取数据中可以直接使用字符串进行索引提取值。</li>
<li>关于格式验证的问题就是正则表达式的问题</li>
<li>表单验证的问题简单一点就是使用简单的判断逻辑进行判断同时还三个与安全性相关的函数保证在用户输入非法字符的时候保证程序不崩溃，在处理用户输入的时候要注意，因为用户的输入很容易对程序造成毁灭性的灾难，这些东西还很有可能会被黑客利用攻击网站，例如一些行家插入一些PHP语言的东西就可以直接获取后台的东西。这些内容需要深入的研究。</li>
</ol>
<p><img src="/images/first.jpg" alt=""></p>
<p><img src="/images/second.jpg" alt=""></p>
<p><img src="/images/third.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/18/once_study/" data-id="cj0rcx64800071kuomsgrogy4" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-little_bean" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/little_bean/" class="article-date">
  <time datetime="2017-03-16T06:20:07.573Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/little_bean/">little bean</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Hello, I am little bean.Can you tell me who you are?</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/little_bean/" data-id="cj0rcx62200021kuoqk9d09ik" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/hello-world/" class="article-date">
  <time datetime="2017-03-16T06:00:16.001Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/hello-world/" data-id="cj0rcx60r00001kuoym4h42mi" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/27/双系统/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/24/是什么？/">是什么？</a>
          </li>
        
          <li>
            <a href="/2017/03/21/简单网络爬虫/">java简单爬虫制作并爬取图片</a>
          </li>
        
          <li>
            <a href="/2017/03/19/制作自己的qq机器人/">实现自己的qq机器人</a>
          </li>
        
          <li>
            <a href="/2017/03/19/制作自己的博客并上传/">制作自己的博客并上传</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>