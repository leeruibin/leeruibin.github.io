<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-制作自己的qq机器人" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/制作自己的qq机器人/" class="article-date">
  <time datetime="2017-03-19T08:08:58.035Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/制作自己的qq机器人/">实现自己的qq机器人</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现自己的qq机器人<br>需要python环境配置<br><a href="https://github.com/pandolia/qqbot" target="_blank" rel="external">https://github.com/pandolia/qqbot</a>   到该网址下下载qqbot安装<br>推荐在linux下使用会比较方便安装python等比较简单，win下安装完python环境之后需要再配置python环境，具体操作看网上教程</p>
<p>QQBOT<br>一、介绍</p>
<p>QQBot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的简单 QQ 机器人，可运行在 Linux 、 Windows 和 Mac OSX 平台下。</p>
<p>本项目 github 地址： <a href="https://github.com/pandolia/qqbot" target="_blank" rel="external">https://github.com/pandolia/qqbot</a></p>
<p>你可以通过扩展 QQBot 来实现：</p>
<p>监控、收集 QQ 消息<br>自动消息推送<br>聊天机器人<br>通过 QQ 远程控制你的设备<br>二、安装方法</p>
<p>在 Python 2.7/3.4/3.5 下使用，用 pip 安装，安装命令：</p>
<p>$ pip install qqbot<br>三、使用方法</p>
<ol>
<li>启动 QQBot</li>
</ol>
<p>在命令行输入： qqbot 。启动过程中会自动弹出二维码图片，需要用手机 QQ 客户端扫码并授权登录。启动成功后，会将本次登录信息保存到本地文件中，下次启动时，可以输入： qqbot -q qq号码 ，先尝试从本地文件中恢复登录信息（不需要手动扫码），只有恢复不成功或登录信息已过期时才会需要手动扫码登录。一般来说，保存的登录信息将在 2 ~ 3 天之后过期。</p>
<p>注意： Linux 下，需要系统中有 gvfs-open 或者 shotwell 命令才能自动弹出二维码图片（一般安装有 GNOME 虚拟文件系统 gvfs 的系统中都会含这两个命令之一）。 Windows10 下，需要系统中已设置了 png 图片文件的默认打开程序才能自动弹出二维码图片。</p>
<p>若系统无法自动弹出二维码图片，可以手动打开图片文件进行扫码，也可以将二维码显示模式设置为邮箱模式或服务器模式进行远程扫码，详见本文档的第六节。</p>
<ol>
<li>操作 QQBot</li>
</ol>
<p>QQBot 启动后，在另一个控制台窗口使用 qq 命令来操作 QQBot ，目前提供以下命令：</p>
<p>1） 帮助<br>    qq help</p>
<p>2） 列出所有 好友/群/讨论组<br>    qq list buddy|group|discuss</p>
<p>3） 向 好友/群/讨论组 发送消息<br>    qq send buddy|group|discuss x|uin=x|qq=x|name=x|nick=x|mark=x message</p>
<p>4） 获取 好友/群/讨论组 的信息<br>    qq get buddy|group|discuss x|uin=x|qq=x|name=x|nick=x|mark=x</p>
<p>5) 获取 群/讨论组 的成员<br>    qq member group|discuss x|uin=x|qq=x|name=x|mark=x</p>
<p>6） 停止 QQBot<br>    qq stop</p>
<p>7） 重启 QQBot （需要手工扫码登陆）<br>    qq restart<br>在 send/get/member 命令中，第三个参数可以是 好友/群/讨论组 的 名称/昵称/备注名/qq/uin 。</p>
<p>QQBot 启动后，用另外一个 QQ 向本 QQ 发送 “–version” ，则 QQBot 会自动回复： “QQBot-v2.x.x” 。（注：2.0.3之前的版本中，通过 QQ 消息发送以上 6 个命令也可以操作 QQBot , 2.0.4 版之后，为安全起见，去掉此功能，只保留一个 “–version” 的命令用来远程测试 QQBot 是否正常运行）。</p>
<p>四、实现你自己的 QQ 机器人</p>
<p>实现自己的 QQ 机器人非常简单，只需要生成一个 QQBot 对象并为其注册一个消息响应函数。示例代码：</p>
<p>from qqbot import QQBot</p>
<p>myqqbot = QQBot()</p>
<p>@myqqbot.On(‘qqmessage’)<br>def handler(bot, message):<br>    if message.content == ‘-hello’:<br>        bot.SendTo(message.contact, ‘你好，我是QQ机器人’)<br>    elif message.content == ‘-stop’:<br>        bot.SendTo(message.contact, ‘QQ机器人已关闭’)<br>        bot.Stop()</p>
<p>myqqbot.LoginAndRun()<br>以上代码运行后，用另外一个 QQ 向本 QQ 发送消息 “-hello”，则会自动回复 “你好，我是 QQ 机器人”，发送消息 “-stop” 则会关闭 QQ 机器人。</p>
<p>QQBot 对象收到一条 QQ 消息时，会新建一个 QQMessage 对象，之后将这个 QQMessage 对象以及自身传递给消息响应函数。</p>
<p>消息响应函数中的第一个参数为传递来的 QQBot 对象，也就是 myqqbot ，第二个参数是传递来的 QQMessage 对象，该对象主要有以下四个属性：</p>
<p>message.contact    ： QContact对象，消息发送者<br>message.memberUin  ： str 对象，消息发送成员的 uin，仅在该消息为 群/讨论组 消息时有效<br>message.memberName ： str 对象，消息发送成员的昵称，仅在该消息为 群/讨论组 消息时有效<br>message.content    ： str 对象，消息内容<br>QQMessage 对象还提供一个 Reply 接口，可以给消息发送者回复消息，如：</p>
<p>message.Reply(‘你好，我是QQ机器人’) # 相当于 bot.SendTo(message.contact, ‘你好，我是QQ机器人’)<br>message.contact 是一个 QContact 对象，该对象有以下属性：</p>
<p>contact.ctype    : str 对象，联系人类型，可以为 ‘buddy’, ‘group’, ‘discuss’ ，代表 好友/群/讨论组<br>contact.uin      : str 对象，联系人的 uin ，底层发消息要使用本数值，每次登录本数值可能会改变<br>contact.qq       : str 对象，联系人的 qq<br>contact.name     : str 对象，联系人的名称<br>contact.nick     : str 对象，好友的昵称<br>contact.mark     : str 对象，好友或群的备注名<br>contact.members  : dict 对象，群或讨论组的成员字典<br>还提供一个 GetMemberName 接口，可以通过成员的 uin 查询成员的网名：</p>
<p>contact.GetMemberName(memberUin) –&gt; memberName, str object<br>五、 QQBot 对象的接口</p>
<p>QQBot 对象调用其 Login 方法登录成功后，提供 List/Get/SendTo/Send/On 五个接口，一般来说，只需要调用这五个接口就可以了，不必关心 QQBot 的内部细节。</p>
<p>（1） bot.List(ctype) –&gt; [contact0, contact1, …, ]</p>
<p>对应上面的 list 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.List(‘buddy’)<br>bot.List(‘group’)<br>bot.List(‘discuss’)<br>…<br>返回一个联系人对象（QContact对象）列表。</p>
</blockquote>
</blockquote>
</blockquote>
<p>（2） bot.Get(ctype, <em>args, *</em>kwargs) –&gt; [contact0, contact1, …, ]</p>
<p>对应上面的 get 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.Get(‘buddy’, ‘jack’)<br>bot.Get(‘group’, ‘1234556’)<br>bot.Get(‘buddy’, ‘qq=1235778’)<br>bot.Get(‘buddy’, uin=’1234768’)<br>bot.Get(‘discuss’, name=’disc-name’)<br>bot.Get(‘buddy’, mark=’jack’)<br>第二个参数可以为联系人的 名称/昵称/备注名/qq/uin ，注意，这里返回的是一个 QContact 对象的列表，而不是返回一个 QContact 对象。</p>
</blockquote>
</blockquote>
</blockquote>
<p>（3） bot.SendTo(contact, content) –&gt; ‘向 xx 发消息成功’</p>
<p>向联系人发送消息。第一个参数为 QContact 对象，一般通过 Get 接口得到，第二个参数为消息内容。</p>
<p>（4） bot.Send(ctype, <em>args, *</em>kwargs) –&gt; [‘向 xx 发消息成功’, ‘向 xx 发消息成功…’, …, ]</p>
<p>对应上面的 send 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.Send(‘buddy’, ‘jack’, ‘hello’)<br>bot.Send(‘group’, ‘1234556’, ‘hello’)<br>bot.Send(‘buddy’, ‘qq=1235778’, ‘hello’)<br>bot.Send(‘buddy’, uin=’1234768’, content=’hello’)<br>bot.Send(‘discuss’, name=’disc-name’, content=’hello’)<br>Send 接口的第一、二个参数和 Get 接口的一样，第三个参数为消息内容。上面的第一条语句相当于：</p>
</blockquote>
</blockquote>
</blockquote>
<p>result = []<br>for contact in bot.Get(‘buddy’, ‘jack’):<br>    result.append(bot.SendTo(contact, ‘hello’))<br>return result<br>（5） bot.On(mtype, callback) –&gt; callback</p>
<p>注册消息响应函数。第一个参数 mtype 为需要响应的消息的类型，一般来说，只需要响应 QQ 消息和 qterm 客户端消息， mtype 分别为 ‘qqmessage’ 和 ‘termmessage’ 。第二个参数 callback 为消息响应函数。</p>
<p>当 QQBot 收到这两种消息时，会新建一个 QQMessage 对象或 TermMessage 对象，连同 QQBot 对象本身一起传递给 callback 。这两种消息对象都有 content 属性和 Reply 接口，content 代表消息内容， Reply 接口可以向消息的发送者回复消息，对于 TermMessage 对象，消息发送者就是 qterm 客户端，注意，对于所有 TermMessage ，都必须调用一次 Reply ，否则 qterm 客户端会一直等待此回复消息。</p>
<p>六、二维码管理器、QQBot 配置、掉线后自动重启、命令行参数</p>
<p>SmartQQ 登录时需要用手机 QQ 扫描二维码图片，在 QQBot 中，二维码图片可以通过以下三种模式显示：</p>
<p>GUI模式： 在 GUI 界面中自动弹出二维码图片<br>邮箱模式： 将二维码图片发送到指定的邮箱<br>服务器模式： 在一个 HTTP 服务器中显示二维码图片<br>GUI 模式是默认的模式，只适用于个人电脑。邮箱模式可以适用于个人电脑和远程服务器。服务器模式一般只在有公网ip的系统中使用。最方便的是使用 QQ 邮箱的邮箱模式，当发送二维码图片后，手机 QQ 客户端一般会立即收到通知，在手机 QQ 客户端上打开邮件，再长按二维码就可以扫描了。</p>
<p>注意：当开启了邮箱模式或服务器模式时， GUI 模式是关闭的，登陆时不会自动弹出二维码图片。</p>
<p>每次登录时会创建一个二维码管理器 （QrcodeManager 对象） ，二维码管理器会根据配置文件及命令行参数来选择二维码图片的显示方式。</p>
<p>配置文件为 ~/.qqbot-tmp/v2.x.conf ，第一次运行 QQBot 后就会自动创建这个配置文件，其中内容如下：</p>
<p>{</p>
<pre><code># QQBot 的配置文件

# 用户 somebody 的配置
&quot;somebody&quot; : {

    # QQBot-term 服务器端口号
    &quot;termServerPort&quot; : 8188,

    # http 服务器 ip，请设置为空字符串或公网 ip
    &quot;httpServerIP&quot; : &quot;127.0.0.1&quot;,

    # http 服务器端口号
    &quot;httpServerPort&quot; : 8189,

    # 自动登录的 QQ 号
    &quot;qq&quot; : &quot;3497303033&quot;,

    # 接收二维码图片的邮箱账号
    &quot;mailAccount&quot; : &quot;3497303033@qq.com&quot;,

    # 该邮箱的 IMAP/SMTP 服务授权码
    &quot;mailAuthCode&quot; : &quot;feregfgftrasdsew&quot;,

    # 显示/关闭调试信息
    &quot;debug&quot; : False,

    # QQBot 掉线后自动重启
    &quot;restartOnOffline&quot; : False,

},

# 请勿修改本项中的设置
&quot;默认配置&quot; : {
    &quot;termServerPort&quot; : 8188,
    &quot;httpServerIP&quot; : &quot;&quot;,
    &quot;httpServerPort&quot; : 8189,
    &quot;qq&quot; : &quot;&quot;,
    &quot;mailAccount&quot; : &quot;&quot;,
    &quot;mailAuthCode&quot; : &quot;&quot;,
    &quot;debug&quot; : False,
    &quot;restartOnOffline&quot; : False,
},
</code></pre><p>}<br>如果需要使用邮箱模式，可以在配置文件中新增一个用户配置（如 somebody ），在该用户下的 mailAccount 和 mailAuthCode 项中分别设置邮箱帐号和授权码，启动 QQBot 时，输入 qqbot -u somebody ，开始运行后，二维码管理器会将二维码图片发送至该邮箱。</p>
<p>注意：授权码不是邮箱的登录密码，而是邮箱服务商提供的开通 IMAP/SMTP 服务的授权码， QQ 邮箱可以在网页版的邮箱设置里面开通此项服务，并得到授权码。如果只定义了 mailAccount 而没定义 mailAuthCode ，则程序运行的开始时会要求手工输入此授权码。</p>
<p>由于网易的邮箱对 IMAP 协议的支持非常有限，无法在 QQBot 中使用。 QQ 的邮箱已通过测试，其他服务商的邮箱还未测试过，因此建议还是使用 QQ 邮箱。</p>
<p>如果需要使用服务器模式，可以配置 httpServerIP 和 httpServerPort 项，一般来说应该设置为公网 ip 。服务器模式开启后，可以通过 <a href="http://httpServerIP:httpServerPort/qqbot/qrcode" target="_blank" rel="external">http://httpServerIP:httpServerPort/qqbot/qrcode</a> 来访问二维码图片。</p>
<p>当邮箱模式和服务器模式同时开启时，发邮件时不会发送真正的图片，只会将图片地址发到邮箱中去，而且只发送一次，二维码过期时刷新一下邮件就可以了。如果只开启邮箱模式，则发邮件时会发送真正的图片，当二维码过期时，需要手动将邮件删除，删除之后才会发送最新的二维码图片。</p>
<p>配置文件中每个用户都有 qq 这一项，如果在某用户（如 somebody ）下设置了此项，则在命令行中输入 qqbot -u somebody 启动后，会先使用此 QQ 号上次登录保存的登录信息来自动登录。</p>
<p>如果配置文件中将 restartOnOffline 项设置为 True ，则当 QQBot 掉线或出错终止时，会自动重新启动 QQBot 。</p>
<p>配置文件中的所有选项都有对应的命令行参数，在命令行参数中输入的选项优先级比配置文件高。输入 qqbot -h 可查看所有命令行参数格式。</p>
<p>如果配置的 QQBot-term 服务器端口号不是默认的 8188 ，那么在运行 qterm 或 qq 命令时，需要在第一个参数中指定端口号，如：</p>
<p>$ qterm 8100<br>$ qq 8100 send buddy jack hello<br>$ qq 8100 member group chatbot</p>
<p>转载自github pandolia</p>
<p>至此qqbot安装与检测完成<br>接下来需要写一个python小程序来响应响应的输入与输出<br>在此之前需要现在图灵机器人网站注册账号新建一个机器人配置完成后并获取API地址，API key，<br><img src="/images/xiaoying.png" alt=""><br>可进行测试例如api地址=www.ro<strong><em>.com省略<br>api key = 4321532<br>输入网址可进行测试<br>例：www.ro</em></strong>.com？key=4321532&amp;info=你是谁<br>如果实现成功会在在网页上看到网页的回复，回复是一个json，至于什么是json自行百度<br>如果这些已经完成就可以进入最后一步了<br>如下已实现的代码</p>
<p>from qqbot import QQBot<br>import urllib<br>import urllib2<br>import cookielib<br>import json<br>import sys<br>reload(sys)<br>sys.setdefaultencoding(‘utf-8’)</p>
<p>#cookie = cookielib.CookieJar()<br>opener = urllib2.build_opener()<br>url = ‘www.ro<em>*</em>.com？key=4321532&amp;info=’<br>opener.addheaders = [(‘User-agent’, ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:47.0) Gecko/20100101 Firefox/47.0’)]<br>myqqbot = QQBot()</p>
<p>@myqqbot.On(‘qqmessage’)<br>def handler(bot, message):<br>    reply = opener.open(url+message.content)<br>    str = reply.read()<br>    data = json.loads(str)<br>    bot.SendTo(message.contact, data[“text”].decode(“utf8”))<br>    if message.content == ‘-stop’:<br>        bot.SendTo(message.contact, ‘QQ机器人已关闭’)<br>        bot.Stop()<br>        conn.close()</p>
<p>myqqbot.LoginAndRun()</p>
<p>运行上述代码并扫码登陆之后就可以实现你自己的机器人了，想要动手的就立即执行把。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/制作自己的qq机器人/" data-id="cj0geo2so00049wuob16sgra6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-制作自己的博客并上传" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/制作自己的博客并上传/" class="article-date">
  <time datetime="2017-03-19T07:49:41.806Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/19/制作自己的博客并上传/">制作自己的博客并上传</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用hexo搭建博客并上传GitHub<br>之前在博客园、简书、CSDN等地儿都开过博，一篇文章写好了，我希望能在几个平台可以同步发布，可是操作起来成本不低。几个平台下的富文本编辑器比较起来还是博客园更顺手，看着更舒服，尤其是代码块的操作灵活、准确。而CSDN对代码块内的文字加粗、修改字色后就会出现html文无法解析的情况，混杂着代码和html文本实在太难看了，后来我知道原来是Markdown的代码块规则限制。而且CSDN刚刚才取消了提交文章要审核通过才能发布的限制，审核没有完成之前，连自己都看不到，且不能修改，这让我一度放弃CSDN平台。如果是写普通的文章写作体验最好的是简书，大气、简洁。但简书更适合一般的写作，比较技术化的中间掺杂大量代码的支持还不够好。</p>
<p>作为一名程序员，应该到GitHub上开博，这里是程序员的圣城。花了两天时间研究了一下，发现还蛮简单的，而且md格式也被博客园、简书、CSDN所支持，写完一份应该比较容易复制到这三个平台。我喜欢在本地编辑markdown文件，使用sublime 及其插件Markdown Editing 和 OmniMarkupPreviewer。完成后底稿、资源文件都悉数保存到GitHub，日后查找、修改都很容易。</p>
<p>我用hexo作为静态页面生成器，操作过程遇到不少问题，搞定之后留一份操作记录吧。以后就把[<a href="http://palanceli.github.io/blog/]作为我的首发平台了" target="_blank" rel="external">http://palanceli.github.io/blog/]作为我的首发平台了</a>;)</p>
<p>安装环境<br>安装node.js，去官网下载安装即可，我安装的是最新稳定版。<br>安装Hexo<br>sudo npm install -g hexo</p>
<p>创建hexo目录并初始化</p>
<p>$ mkdir hexo<br>$ cd hexo<br>$ hexo init<br>然后就可以生成网站，启动服务了：</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>hexo文件夹<br>先来看一下hexo文件夹下的内容：</p>
<p>hexo/<br>  |- node_modules/  # hexo需要的模块，不需要上传GitHub<br>  |- themes/        # 主题文件，需要上传GitHub的dev分支<br>  |- sources/       # 博文md文件，需要上传GitHub的dev分支<br>  |- public/        # 生成的静态页面，由hexo deploy自动上传到gh-page分支<br>  |- package.json   # 记录hexo需要的包信息，不需要上传GitHub<br>  |- _config.yml    # 全局配置文件，需要上传GitHub的dev分支<br>  |- .gitignore     # hexo生成默认的.gitignore，它已经配置好了不需要上传的hexo文件<br>关联GitHub<br>首次先创建GitHub工程blog，并且使用“Launch automatic page generator”生成页面，它会给该工程创建分支gh-pages。<br>手动为之创建dev分支，未来工程源码会放到dev分支下；hexo生成的网站静态页面会放到gh-pages分支。</p>
<p>首次创建GitHub工程后操作dev分支代码<br>如果是刚创建的GitHub工程，clone dev分支的代码到本地blog-dev/，然后把前面hexo/文件夹下的内容全部拷贝到blog-dev/，注意包括一个隐藏文件.gitignore。</p>
<p>已存在GitHub工程的恢复<br>仍是clone dev分支的代码到本地blog-dev/，然后把hexo/node_modules/拷贝到blog-dev/<br>再试试生成页面、启动服务，确保是正常的：</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>网上有介绍把package.json文件同步到GitHub，以后每次恢复时执行</p>
<p>$ npm install hexo<br>$ npm install<br>$ npm install hexo-deployer-git –save<br>可是我在不同的机器上试总是出错。只好采取笨办法，每次先hexo init出一个完整文件夹，再把相关文件拷贝到GitHub目录下。千万不要先clone 了blog目录，再在该目录下执行hexo init，因为init会把.git信息删掉。</p>
<p>配置自己的_config.yml<br>按照如下内容修改blog-dev/_config.yml：</p>
<p>title: Palance’s Blog   # 标题<br>subtitle:<br>description:<br>author: Palance Li<br>language: zh-CN         # 语言设置<br>url: <a href="http://palanceli.github.io/blog" target="_blank" rel="external">http://palanceli.github.io/blog</a><br>root: /blog/<br>翻到最下面，改成：</p>
<p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a>&lt;自己的github账号&gt;/blog.git<br>  branch: gh-pages<br>主题<br>这里有大量的主题<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">https://github.com/hexojs/hexo/wiki/Themes</a><br>我非常喜欢Maupassant：<a href="https://www.haomwei.com/technology/maupassant-hexo.html，" target="_blank" rel="external">https://www.haomwei.com/technology/maupassant-hexo.html，</a><br>简洁清晰，而且适配手机、PC各个平台。</p>
<p>安装方法<br>首次在blog-dev/目录下执行如下命令</p>
<p>$ git clone <a href="https://github.com/tufu9441/maupassant-hexo.git" target="_blank" rel="external">https://github.com/tufu9441/maupassant-hexo.git</a> themes/maupassant<br>$ npm install hexo-renderer-jade –save<br>$ npm install hexo-renderer-sass –save<br>以后建议把blog-dev/themes/maupassant/.git文件夹删掉，把maupassant文件夹随自己的blog-dev上传到GitHub。<br>以后clone blog-dev后，执行完前面的安装操作步骤后记得执行</p>
<p>$ npm install hexo-renderer-jade –save<br>$ npm install hexo-renderer-sass –save<br>配置<br>在blog-dev/themes/maupassant/_config.yml中根据自己的情况修改，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">links:</div><div class="line">title: 我的博客园</div><div class="line">url: http://www.cnblogs.com/palance/</div><div class="line">title: 我的CSDN</div><div class="line">url: http://blog.csdn.net/zchongr</div><div class="line">title: 我的简书</div><div class="line">url: http://www.jianshu.com/users/5e527164a8c2</div><div class="line"></div><div class="line">在blog-dev/_config.yml中修改:</div><div class="line">theme: maupassant</div></pre></td></tr></table></figure></p>
<p>第一次的工作就完成了，可以提交github到blog-dev了。</p>
<p>上传生成页面<br>执行</p>
<p>$ cd blog-dev<br>$ npm install hexo-deployer-git<br>以后每次执行完</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>生成了静态页面后就可以执行</p>
<p>hexo deploy<br>完成页面上传。</p>
<p>其它<br>图片<br>首先确认_config.yml中有：</p>
<p>post_asset_folder: true<br>然后在blog-dev/下执行</p>
<p>npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">https://github.com/CodeFalling/hexo-asset-image</a> –save<br>确保在blog-dev/source/_posts下创建和md文件同名的目录，在里面放该md需要的图片，然后在md中插入</p>
<p><img src="目录名/文件名.png" alt=""><br>即可在hexo generate时正确生成插入图片。比如：</p>
<p><em>posts<br>    |- post1.md<br>    |</em> post1<br>        |- pic1.png<br>在md文件中插入图片时只需写</p>
<p><img src="post1/pic1.png" alt=""><br>即可。首次配置完了需要执行一次清除操作，再生成页面：</p>
<p>$ hexo clean<br>$ hexo generate<br>$ hexo server<br>如果没做清除，直接生成页面，在我这里会出现路径错误的情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/制作自己的博客并上传/" data-id="cj0geo2sl00029wuostbmhg3a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-once_study" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/18/once_study/" class="article-date">
  <time datetime="2017-03-18T12:01:43.519Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/18/once_study/">once_study</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【TCP/IP协议】<br>之前有看过过关于TCP/IP协议的书籍，所以这次再次看tcp/ip协议相关的东西还是有一点熟悉的，但是由于当时看只是为了大致了解一下计算机网络的构造是怎么样的所以当时就没没有更加细致的了解相关的内容，再次接触的时候相对于之前了解的东西更多了一点，tcp/ip协议包括一系列的协议，不同的协议保证不同功能的传输，如tcp协议主要是用于应用程序之间的通讯，而ip协议主要用于计算机之间的通讯，之后介绍的相关的一些名词我大致可以理解如“握手”我个人理解是相当于连接的概念。<br>但是我保留了一个问题，介绍中所说的“这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。“，我不是特别明白这个通讯线路指的是什么，按前边与后边的介绍，tcp协议主要负责的是程序间的通讯，把程序要发送的数据包装成ip报的形式通过ip协议发送出去，按照我的理解tcp协议占用计算机本机高层通道使电脑的高层程序的数据能够发送，是这个通道被解释为两个计算机间的通讯线路还是另有其他的东西。<br>还有就是关于ip协议，计算机的网卡会有一个单独的48位mac地址，而计算机接入网络的时候又会分配一个32位的ip地址，我在搜索相关知识之后感觉对到底是ip寻址还是mac地址寻址产生了 混乱的理解，如下搜到的一段关于mac地址的知识：<br>数据包在这些节点之间的移动都是由ARP负责将IP地址映射到MAC地址上来完成的。其实人类社会和网络也是类似的，试想在人际关系网络中，甲要捎个口信给丁，就会通过乙和丙中转一下，最后由丙 转告给丁。在网络中，这个口信就好比是一个网络中的一个数据包。数据包在传送过程中会不断询问相邻节点的MAC地址，这个过程就好比是人类社会的口信传送过程。相信通过这两个例子，我们就可以进一步理解MAC地址的作用。</p>
<p>所以在网络中到底是直接对ip地址寻址找到ip对应即找到要发送方，还是通过ip找到对应的路由器再由路由器查询其mac地址的表格发送ip包，我对这点有点疑问。<br>【PHP】</p>
<p>PHP基础<br>在了解了一些PHP基础的知识之后发现其实大部分的基础都c，java这些语言差不多包括函数的定义，分支结构，循环结构等大部分基础的操作可以直接从其他语言基础转移，有一些不同之处在于：</p>
<ol>
<li>一些特别的函数名称不太相同如输出语句即可以用print也可以用echo进行输出.</li>
<li>但相当其他语言对数据的定义来说，PHP对数据的定义并没有那么的严格，而且有很多种类型的数据都可以按照字符串来定义，神奇的是我发现PHP语言对字符串的理解能力很强，在很多情况下他可以直接从字符串里边读出整数等，可以将特定的数据从字符串中分离出来而不像c和java这种语言字符串就是字符串.</li>
<li>特别的PHP的逻辑运算符还有一个全等的比较，由于PHP对符号的应用比较多对字符串的识别能力也很强大如“100”=100，但是比较还有一个全等的比较那样只有数值相等并且数据类型相同才返回真值。</li>
<li>PHP数组的功能也比较全，吸取了map，set等的思想，数组定义不仅可以定义以数字为索引的数组，还可以定义以自定义字符索引的数组，相当于一个map</li>
<li>字符串的相关函数有很多，熟悉之后可以熟悉相关的功能。</li>
<li>PHP有一种独特的数据类型，超全局变量，对于超全局变量我的理解还没有太全，我现在的理解是他是PHP语言定义的一类存储相关的特别数据的一类数据，通过访问这些全局变量数组的值可以返回特定的数据，如SERVER可以返回关于脚本的信息。但由于我对脚本的理解比较少，所以我对讲解所说的脚本这些东西没有什么概念，我现在的理解是脚本是程序但不知道他被称为脚本的原因。</li>
</ol>
<p>PHP表格<br>由于我是先看的PHP之前没有看相关的HTML语言的相关知识的积累所以对页面中的实例的理解不是特别到位</p>
<ol>
<li>首先我对HTML的表单的一些知识有一些大致的了解但不是特别深入，例如：<br>Name: <input type="text" name="name"><br>E-mail: <input type="text" name="email"><br>Website: <input type="text" name="website"><br>Comment: <textarea name="comment" rows="5" cols="40"></textarea><br>这段代码中我的大致的理解是input 相当与一类声明表示输入模式，  type name这些都是特殊的字符串名称有特定的意义，不是编程用户定义的内容。</li>
<li>在表单的处理中 action方法是用户自己的PHP代码用于实现相关的功能，method=port 或 get重，这是会用到超全局变量，我是这样理解的，method的这两个东西会将数据保存到超全局变量中去，编程者可以从那些变量中获取到数据。而且在获取数据中可以直接使用字符串进行索引提取值。</li>
<li>关于格式验证的问题就是正则表达式的问题</li>
<li>表单验证的问题简单一点就是使用简单的判断逻辑进行判断同时还三个与安全性相关的函数保证在用户输入非法字符的时候保证程序不崩溃，在处理用户输入的时候要注意，因为用户的输入很容易对程序造成毁灭性的灾难，这些东西还很有可能会被黑客利用攻击网站，例如一些行家插入一些PHP语言的东西就可以直接获取后台的东西。这些内容需要深入的研究。</li>
</ol>
<p><img src="/images/first.jpg" alt=""></p>
<p><img src="/images/second.jpg" alt=""></p>
<p><img src="/images/third.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/18/once_study/" data-id="cj0geo2sj00019wuocob725bq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-little_bean" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/little_bean/" class="article-date">
  <time datetime="2017-03-16T06:20:07.573Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/little_bean/">little bean</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Hello, I am little bean.Can you tell me who you are?</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/little_bean/" data-id="cj0geo2sn00039wuoctyo6lkr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/16/hello-world/" class="article-date">
  <time datetime="2017-03-16T06:00:16.001Z" itemprop="datePublished">2017-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/16/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/16/hello-world/" data-id="cj0geo2sf00009wuof5jh23cq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/19/制作自己的qq机器人/">实现自己的qq机器人</a>
          </li>
        
          <li>
            <a href="/2017/03/19/制作自己的博客并上传/">制作自己的博客并上传</a>
          </li>
        
          <li>
            <a href="/2017/03/18/once_study/">once_study</a>
          </li>
        
          <li>
            <a href="/2017/03/16/little_bean/">little bean</a>
          </li>
        
          <li>
            <a href="/2017/03/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>