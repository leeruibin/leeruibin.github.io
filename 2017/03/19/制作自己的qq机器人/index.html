<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>实现自己的qq机器人 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="实现自己的qq机器人需要python环境配置https://github.com/pandolia/qqbot   到该网址下下载qqbot安装推荐在linux下使用会比较方便安装python等比较简单，win下安装完python环境之后需要再配置python环境，具体操作看网上教程
QQBOT一、介绍
QQBot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的简单 QQ 机器人">
<meta property="og:type" content="article">
<meta property="og:title" content="实现自己的qq机器人">
<meta property="og:url" content="http://yoursite.com/2017/03/19/制作自己的qq机器人/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="实现自己的qq机器人需要python环境配置https://github.com/pandolia/qqbot   到该网址下下载qqbot安装推荐在linux下使用会比较方便安装python等比较简单，win下安装完python环境之后需要再配置python环境，具体操作看网上教程
QQBOT一、介绍
QQBot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的简单 QQ 机器人">
<meta property="og:image" content="http://yoursite.com/images/xiaoying.png">
<meta property="og:updated_time" content="2017-03-19T08:12:36.423Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现自己的qq机器人">
<meta name="twitter:description" content="实现自己的qq机器人需要python环境配置https://github.com/pandolia/qqbot   到该网址下下载qqbot安装推荐在linux下使用会比较方便安装python等比较简单，win下安装完python环境之后需要再配置python环境，具体操作看网上教程
QQBOT一、介绍
QQBot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的简单 QQ 机器人">
<meta name="twitter:image" content="http://yoursite.com/images/xiaoying.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-制作自己的qq机器人" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/19/制作自己的qq机器人/" class="article-date">
  <time datetime="2017-03-19T08:08:58.035Z" itemprop="datePublished">2017-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      实现自己的qq机器人
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>实现自己的qq机器人<br>需要python环境配置<br><a href="https://github.com/pandolia/qqbot" target="_blank" rel="external">https://github.com/pandolia/qqbot</a>   到该网址下下载qqbot安装<br>推荐在linux下使用会比较方便安装python等比较简单，win下安装完python环境之后需要再配置python环境，具体操作看网上教程</p>
<p>QQBOT<br>一、介绍</p>
<p>QQBot 是一个用 python 实现的、基于腾讯 SmartQQ 协议的简单 QQ 机器人，可运行在 Linux 、 Windows 和 Mac OSX 平台下。</p>
<p>本项目 github 地址： <a href="https://github.com/pandolia/qqbot" target="_blank" rel="external">https://github.com/pandolia/qqbot</a></p>
<p>你可以通过扩展 QQBot 来实现：</p>
<p>监控、收集 QQ 消息<br>自动消息推送<br>聊天机器人<br>通过 QQ 远程控制你的设备<br>二、安装方法</p>
<p>在 Python 2.7/3.4/3.5 下使用，用 pip 安装，安装命令：</p>
<p>$ pip install qqbot<br>三、使用方法</p>
<ol>
<li>启动 QQBot</li>
</ol>
<p>在命令行输入： qqbot 。启动过程中会自动弹出二维码图片，需要用手机 QQ 客户端扫码并授权登录。启动成功后，会将本次登录信息保存到本地文件中，下次启动时，可以输入： qqbot -q qq号码 ，先尝试从本地文件中恢复登录信息（不需要手动扫码），只有恢复不成功或登录信息已过期时才会需要手动扫码登录。一般来说，保存的登录信息将在 2 ~ 3 天之后过期。</p>
<p>注意： Linux 下，需要系统中有 gvfs-open 或者 shotwell 命令才能自动弹出二维码图片（一般安装有 GNOME 虚拟文件系统 gvfs 的系统中都会含这两个命令之一）。 Windows10 下，需要系统中已设置了 png 图片文件的默认打开程序才能自动弹出二维码图片。</p>
<p>若系统无法自动弹出二维码图片，可以手动打开图片文件进行扫码，也可以将二维码显示模式设置为邮箱模式或服务器模式进行远程扫码，详见本文档的第六节。</p>
<ol>
<li>操作 QQBot</li>
</ol>
<p>QQBot 启动后，在另一个控制台窗口使用 qq 命令来操作 QQBot ，目前提供以下命令：</p>
<p>1） 帮助<br>    qq help</p>
<p>2） 列出所有 好友/群/讨论组<br>    qq list buddy|group|discuss</p>
<p>3） 向 好友/群/讨论组 发送消息<br>    qq send buddy|group|discuss x|uin=x|qq=x|name=x|nick=x|mark=x message</p>
<p>4） 获取 好友/群/讨论组 的信息<br>    qq get buddy|group|discuss x|uin=x|qq=x|name=x|nick=x|mark=x</p>
<p>5) 获取 群/讨论组 的成员<br>    qq member group|discuss x|uin=x|qq=x|name=x|mark=x</p>
<p>6） 停止 QQBot<br>    qq stop</p>
<p>7） 重启 QQBot （需要手工扫码登陆）<br>    qq restart<br>在 send/get/member 命令中，第三个参数可以是 好友/群/讨论组 的 名称/昵称/备注名/qq/uin 。</p>
<p>QQBot 启动后，用另外一个 QQ 向本 QQ 发送 “–version” ，则 QQBot 会自动回复： “QQBot-v2.x.x” 。（注：2.0.3之前的版本中，通过 QQ 消息发送以上 6 个命令也可以操作 QQBot , 2.0.4 版之后，为安全起见，去掉此功能，只保留一个 “–version” 的命令用来远程测试 QQBot 是否正常运行）。</p>
<p>四、实现你自己的 QQ 机器人</p>
<p>实现自己的 QQ 机器人非常简单，只需要生成一个 QQBot 对象并为其注册一个消息响应函数。示例代码：</p>
<p>from qqbot import QQBot</p>
<p>myqqbot = QQBot()</p>
<p>@myqqbot.On(‘qqmessage’)<br>def handler(bot, message):<br>    if message.content == ‘-hello’:<br>        bot.SendTo(message.contact, ‘你好，我是QQ机器人’)<br>    elif message.content == ‘-stop’:<br>        bot.SendTo(message.contact, ‘QQ机器人已关闭’)<br>        bot.Stop()</p>
<p>myqqbot.LoginAndRun()<br>以上代码运行后，用另外一个 QQ 向本 QQ 发送消息 “-hello”，则会自动回复 “你好，我是 QQ 机器人”，发送消息 “-stop” 则会关闭 QQ 机器人。</p>
<p>QQBot 对象收到一条 QQ 消息时，会新建一个 QQMessage 对象，之后将这个 QQMessage 对象以及自身传递给消息响应函数。</p>
<p>消息响应函数中的第一个参数为传递来的 QQBot 对象，也就是 myqqbot ，第二个参数是传递来的 QQMessage 对象，该对象主要有以下四个属性：</p>
<p>message.contact    ： QContact对象，消息发送者<br>message.memberUin  ： str 对象，消息发送成员的 uin，仅在该消息为 群/讨论组 消息时有效<br>message.memberName ： str 对象，消息发送成员的昵称，仅在该消息为 群/讨论组 消息时有效<br>message.content    ： str 对象，消息内容<br>QQMessage 对象还提供一个 Reply 接口，可以给消息发送者回复消息，如：</p>
<p>message.Reply(‘你好，我是QQ机器人’) # 相当于 bot.SendTo(message.contact, ‘你好，我是QQ机器人’)<br>message.contact 是一个 QContact 对象，该对象有以下属性：</p>
<p>contact.ctype    : str 对象，联系人类型，可以为 ‘buddy’, ‘group’, ‘discuss’ ，代表 好友/群/讨论组<br>contact.uin      : str 对象，联系人的 uin ，底层发消息要使用本数值，每次登录本数值可能会改变<br>contact.qq       : str 对象，联系人的 qq<br>contact.name     : str 对象，联系人的名称<br>contact.nick     : str 对象，好友的昵称<br>contact.mark     : str 对象，好友或群的备注名<br>contact.members  : dict 对象，群或讨论组的成员字典<br>还提供一个 GetMemberName 接口，可以通过成员的 uin 查询成员的网名：</p>
<p>contact.GetMemberName(memberUin) –&gt; memberName, str object<br>五、 QQBot 对象的接口</p>
<p>QQBot 对象调用其 Login 方法登录成功后，提供 List/Get/SendTo/Send/On 五个接口，一般来说，只需要调用这五个接口就可以了，不必关心 QQBot 的内部细节。</p>
<p>（1） bot.List(ctype) –&gt; [contact0, contact1, …, ]</p>
<p>对应上面的 list 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.List(‘buddy’)<br>bot.List(‘group’)<br>bot.List(‘discuss’)<br>…<br>返回一个联系人对象（QContact对象）列表。</p>
</blockquote>
</blockquote>
</blockquote>
<p>（2） bot.Get(ctype, <em>args, *</em>kwargs) –&gt; [contact0, contact1, …, ]</p>
<p>对应上面的 get 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.Get(‘buddy’, ‘jack’)<br>bot.Get(‘group’, ‘1234556’)<br>bot.Get(‘buddy’, ‘qq=1235778’)<br>bot.Get(‘buddy’, uin=’1234768’)<br>bot.Get(‘discuss’, name=’disc-name’)<br>bot.Get(‘buddy’, mark=’jack’)<br>第二个参数可以为联系人的 名称/昵称/备注名/qq/uin ，注意，这里返回的是一个 QContact 对象的列表，而不是返回一个 QContact 对象。</p>
</blockquote>
</blockquote>
</blockquote>
<p>（3） bot.SendTo(contact, content) –&gt; ‘向 xx 发消息成功’</p>
<p>向联系人发送消息。第一个参数为 QContact 对象，一般通过 Get 接口得到，第二个参数为消息内容。</p>
<p>（4） bot.Send(ctype, <em>args, *</em>kwargs) –&gt; [‘向 xx 发消息成功’, ‘向 xx 发消息成功…’, …, ]</p>
<p>对应上面的 send 命令，示例：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bot.Send(‘buddy’, ‘jack’, ‘hello’)<br>bot.Send(‘group’, ‘1234556’, ‘hello’)<br>bot.Send(‘buddy’, ‘qq=1235778’, ‘hello’)<br>bot.Send(‘buddy’, uin=’1234768’, content=’hello’)<br>bot.Send(‘discuss’, name=’disc-name’, content=’hello’)<br>Send 接口的第一、二个参数和 Get 接口的一样，第三个参数为消息内容。上面的第一条语句相当于：</p>
</blockquote>
</blockquote>
</blockquote>
<p>result = []<br>for contact in bot.Get(‘buddy’, ‘jack’):<br>    result.append(bot.SendTo(contact, ‘hello’))<br>return result<br>（5） bot.On(mtype, callback) –&gt; callback</p>
<p>注册消息响应函数。第一个参数 mtype 为需要响应的消息的类型，一般来说，只需要响应 QQ 消息和 qterm 客户端消息， mtype 分别为 ‘qqmessage’ 和 ‘termmessage’ 。第二个参数 callback 为消息响应函数。</p>
<p>当 QQBot 收到这两种消息时，会新建一个 QQMessage 对象或 TermMessage 对象，连同 QQBot 对象本身一起传递给 callback 。这两种消息对象都有 content 属性和 Reply 接口，content 代表消息内容， Reply 接口可以向消息的发送者回复消息，对于 TermMessage 对象，消息发送者就是 qterm 客户端，注意，对于所有 TermMessage ，都必须调用一次 Reply ，否则 qterm 客户端会一直等待此回复消息。</p>
<p>六、二维码管理器、QQBot 配置、掉线后自动重启、命令行参数</p>
<p>SmartQQ 登录时需要用手机 QQ 扫描二维码图片，在 QQBot 中，二维码图片可以通过以下三种模式显示：</p>
<p>GUI模式： 在 GUI 界面中自动弹出二维码图片<br>邮箱模式： 将二维码图片发送到指定的邮箱<br>服务器模式： 在一个 HTTP 服务器中显示二维码图片<br>GUI 模式是默认的模式，只适用于个人电脑。邮箱模式可以适用于个人电脑和远程服务器。服务器模式一般只在有公网ip的系统中使用。最方便的是使用 QQ 邮箱的邮箱模式，当发送二维码图片后，手机 QQ 客户端一般会立即收到通知，在手机 QQ 客户端上打开邮件，再长按二维码就可以扫描了。</p>
<p>注意：当开启了邮箱模式或服务器模式时， GUI 模式是关闭的，登陆时不会自动弹出二维码图片。</p>
<p>每次登录时会创建一个二维码管理器 （QrcodeManager 对象） ，二维码管理器会根据配置文件及命令行参数来选择二维码图片的显示方式。</p>
<p>配置文件为 ~/.qqbot-tmp/v2.x.conf ，第一次运行 QQBot 后就会自动创建这个配置文件，其中内容如下：</p>
<p>{</p>
<pre><code># QQBot 的配置文件

# 用户 somebody 的配置
&quot;somebody&quot; : {

    # QQBot-term 服务器端口号
    &quot;termServerPort&quot; : 8188,

    # http 服务器 ip，请设置为空字符串或公网 ip
    &quot;httpServerIP&quot; : &quot;127.0.0.1&quot;,

    # http 服务器端口号
    &quot;httpServerPort&quot; : 8189,

    # 自动登录的 QQ 号
    &quot;qq&quot; : &quot;3497303033&quot;,

    # 接收二维码图片的邮箱账号
    &quot;mailAccount&quot; : &quot;3497303033@qq.com&quot;,

    # 该邮箱的 IMAP/SMTP 服务授权码
    &quot;mailAuthCode&quot; : &quot;feregfgftrasdsew&quot;,

    # 显示/关闭调试信息
    &quot;debug&quot; : False,

    # QQBot 掉线后自动重启
    &quot;restartOnOffline&quot; : False,

},

# 请勿修改本项中的设置
&quot;默认配置&quot; : {
    &quot;termServerPort&quot; : 8188,
    &quot;httpServerIP&quot; : &quot;&quot;,
    &quot;httpServerPort&quot; : 8189,
    &quot;qq&quot; : &quot;&quot;,
    &quot;mailAccount&quot; : &quot;&quot;,
    &quot;mailAuthCode&quot; : &quot;&quot;,
    &quot;debug&quot; : False,
    &quot;restartOnOffline&quot; : False,
},
</code></pre><p>}<br>如果需要使用邮箱模式，可以在配置文件中新增一个用户配置（如 somebody ），在该用户下的 mailAccount 和 mailAuthCode 项中分别设置邮箱帐号和授权码，启动 QQBot 时，输入 qqbot -u somebody ，开始运行后，二维码管理器会将二维码图片发送至该邮箱。</p>
<p>注意：授权码不是邮箱的登录密码，而是邮箱服务商提供的开通 IMAP/SMTP 服务的授权码， QQ 邮箱可以在网页版的邮箱设置里面开通此项服务，并得到授权码。如果只定义了 mailAccount 而没定义 mailAuthCode ，则程序运行的开始时会要求手工输入此授权码。</p>
<p>由于网易的邮箱对 IMAP 协议的支持非常有限，无法在 QQBot 中使用。 QQ 的邮箱已通过测试，其他服务商的邮箱还未测试过，因此建议还是使用 QQ 邮箱。</p>
<p>如果需要使用服务器模式，可以配置 httpServerIP 和 httpServerPort 项，一般来说应该设置为公网 ip 。服务器模式开启后，可以通过 <a href="http://httpServerIP:httpServerPort/qqbot/qrcode" target="_blank" rel="external">http://httpServerIP:httpServerPort/qqbot/qrcode</a> 来访问二维码图片。</p>
<p>当邮箱模式和服务器模式同时开启时，发邮件时不会发送真正的图片，只会将图片地址发到邮箱中去，而且只发送一次，二维码过期时刷新一下邮件就可以了。如果只开启邮箱模式，则发邮件时会发送真正的图片，当二维码过期时，需要手动将邮件删除，删除之后才会发送最新的二维码图片。</p>
<p>配置文件中每个用户都有 qq 这一项，如果在某用户（如 somebody ）下设置了此项，则在命令行中输入 qqbot -u somebody 启动后，会先使用此 QQ 号上次登录保存的登录信息来自动登录。</p>
<p>如果配置文件中将 restartOnOffline 项设置为 True ，则当 QQBot 掉线或出错终止时，会自动重新启动 QQBot 。</p>
<p>配置文件中的所有选项都有对应的命令行参数，在命令行参数中输入的选项优先级比配置文件高。输入 qqbot -h 可查看所有命令行参数格式。</p>
<p>如果配置的 QQBot-term 服务器端口号不是默认的 8188 ，那么在运行 qterm 或 qq 命令时，需要在第一个参数中指定端口号，如：</p>
<p>$ qterm 8100<br>$ qq 8100 send buddy jack hello<br>$ qq 8100 member group chatbot</p>
<p>转载自github pandolia</p>
<p>至此qqbot安装与检测完成<br>接下来需要写一个python小程序来响应响应的输入与输出<br>在此之前需要现在图灵机器人网站注册账号新建一个机器人配置完成后并获取API地址，API key，<br><img src="/images/xiaoying.png" alt=""><br>可进行测试例如api地址=www.ro<strong><em>.com省略<br>api key = 4321532<br>输入网址可进行测试<br>例：www.ro</em></strong>.com？key=4321532&amp;info=你是谁<br>如果实现成功会在在网页上看到网页的回复，回复是一个json，至于什么是json自行百度<br>如果这些已经完成就可以进入最后一步了<br>如下已实现的代码</p>
<p>from qqbot import QQBot<br>import urllib<br>import urllib2<br>import cookielib<br>import json<br>import sys<br>reload(sys)<br>sys.setdefaultencoding(‘utf-8’)</p>
<p>#cookie = cookielib.CookieJar()<br>opener = urllib2.build_opener()<br>url = ‘www.ro<em>*</em>.com？key=4321532&amp;info=’<br>opener.addheaders = [(‘User-agent’, ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:47.0) Gecko/20100101 Firefox/47.0’)]<br>myqqbot = QQBot()</p>
<p>@myqqbot.On(‘qqmessage’)<br>def handler(bot, message):<br>    reply = opener.open(url+message.content)<br>    str = reply.read()<br>    data = json.loads(str)<br>    bot.SendTo(message.contact, data[“text”].decode(“utf8”))<br>    if message.content == ‘-stop’:<br>        bot.SendTo(message.contact, ‘QQ机器人已关闭’)<br>        bot.Stop()<br>        conn.close()</p>
<p>myqqbot.LoginAndRun()</p>
<p>运行上述代码并扫码登陆之后就可以实现你自己的机器人了，想要动手的就立即执行把。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/19/制作自己的qq机器人/" data-id="cj52z77zd000310uo94zci8yg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/21/简单网络爬虫/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java简单爬虫制作并爬取图片
        
      </div>
    </a>
  
  
    <a href="/2017/03/19/制作自己的博客并上传/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">制作自己的博客并上传</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/14/summer/">laravel依赖注入,loc,容器</a>
          </li>
        
          <li>
            <a href="/2017/03/27/双系统/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/03/24/是什么？/">是什么？</a>
          </li>
        
          <li>
            <a href="/2017/03/21/简单网络爬虫/">java简单爬虫制作并爬取图片</a>
          </li>
        
          <li>
            <a href="/2017/03/19/制作自己的qq机器人/">实现自己的qq机器人</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>